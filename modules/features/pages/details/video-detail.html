<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>视频详情</title>
  <!-- 引入 SRS 播放依赖（与 player.html 一致） -->
  <script src="/js/adapter-7.4.0.min.js"></script>
  <script src="/js/srs.sdk.js"></script>
  <script src="/js/winlin.utility.js"></script>
  <script src="/js/srs.page.js"></script>
  <style>
    html,body{height:100%;margin:0;background:#000;color:#e6f0ff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; overflow:hidden;}
    *{box-sizing:border-box;}

    /* 整体布局：顶部为公用 Topbar（48px），下方为视频+侧栏 */
    .layout{ position:absolute; inset:48px 0 0 0; display:grid; grid-template-columns: 1fr 320px; }

    /* 左侧视频区域占满 */
    .videoPane{ position:relative; background:#000; }

    /* 画中画播放器容器与样式（移植自 player.html，适配全屏和 PiP 拖动） */
    #video_container{position:absolute; inset:0; background:#000; overflow:hidden; user-select:none; border:none;}
    :fullscreen #video_container,#video_container:fullscreen{width:100vw !important;height:100vh !important;}
    .slot{position:absolute;top:0;left:0;}
    .slot.main{width:100%;height:100%;z-index:1;}
    .slot.pip{
        width:260px;height:146px;z-index:3;
        right:16px;bottom:96px;left:auto;top:auto;
        border:2px solid rgba(255,255,255,.35);border-radius:4px;
        box-shadow:0 4px 14px rgba(0,0,0,.6);
        overflow:hidden;cursor:move;background:#000;
        will-change:transform;
        display:none;
    }
    .slot.dragging{pointer-events:none;}
    .slot canvas,.slot video{position:absolute;top:0;left:0;width:100%;height:100%;}
    .slot video{opacity:0;pointer-events:none;}
    #pip_placeholder{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:12px;color:#bbb;text-align:center;pointer-events:none;}
    .swap-anim{transition:transform .35s ease, opacity .35s ease;will-change:transform;}

    /* 悬浮控制条（移植自 player.html） */
    .controls-overlay{position:absolute;left:0;right:0;bottom:0;padding:6px 10px 10px;display:flex;justify-content:space-between;align-items:flex-end;background:linear-gradient(to top,rgba(0,0,0,.7),rgba(0,0,0,0));opacity:0;pointer-events:none;transition:opacity .25s;z-index:5;}
    #video_container.show-controls .controls-overlay{opacity:1;pointer-events:auto;}
    .left-controls,.right-controls{display:flex;align-items:center;gap:10px;}
    .ctrl-btn{width:34px;height:34px;background:rgba(255,255,255,.12);border:none;color:#fff;border-radius:5px;display:flex;justify-content:center;align-items:center;cursor:pointer;position:relative;padding:0;transition:background .2s;}
    .ctrl-btn:hover{background:rgba(255,255,255,.32);}
    .ctrl-btn svg{width:20px;height:20px;fill:#fff;pointer-events:none;}
    .ctrl-btn[data-tip]:hover:after{content:attr(data-tip);position:absolute;bottom:110%;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.75);padding:3px 6px;font-size:11px;border-radius:3px;white-space:nowrap;pointer-events:none;}
    .volume-group{display:flex;align-items:center;position:relative;}
    .volume-slider{width:120px;margin-left:6px;opacity:0;visibility:hidden;transition:opacity .25s;}
    .volume-group:hover .volume-slider,.volume-slider:hover{opacity:1;visibility:visible;}
    .volume-slider input[type=range]{width:100%;height:6px;background:#444;border-radius:3px;-webkit-appearance:none;appearance:none;outline:none;}
    .volume-slider input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;background:#fff;border-radius:50%;cursor:pointer;}
    .volume-slider input[type=range]::-moz-range-thumb{width:14px;height:14px;background:#fff;border-radius:50%;border:none;cursor:pointer;}

    /* 信息面板（移植自 player.html） */
    #info_panel{position:absolute;top:12px;left:12px;background:rgba(0,0,0,.55);padding:10px 14px;font-size:12px;line-height:1.5;border-radius:6px;min-width:200px;max-width:340px;display:none;z-index:6;backdrop-filter:blur(2px);white-space:nowrap;}
    #info_panel h4{margin:0 0 4px;font-size:13px;font-weight:600;}
    .info-row{display:flex;justify-content:space-between;gap:14px;}
    .badge-role{display:inline-block;padding:1px 6px;font-size:10px;background:#2d8cff;border-radius:10px;margin-left:6px;vertical-align:middle;}
    .badge-role.secondary{background:#888;}

    @media (max-width:900px){
      .layout{ grid-template-columns: 1fr 280px; }
      .slot.pip{width:180px;height:101px;}
    }

    /* 右侧侧栏（沿用原有风格） */
    .side{ border-left:1px solid #1f2a3a; padding:12px; overflow:auto; }
    .ctl{ display:grid; grid-template-columns:repeat(3, 1fr); gap:10px; margin:10px 0; }
    .btn{ background:#1f7fb8; border:1px solid rgba(255,255,255,.25); color:#fff; border-radius:6px; padding:8px; cursor:pointer; text-align:center; white-space:nowrap; }
    .ptz{ display:grid; grid-template-columns:repeat(3, 1fr); gap:6px; justify-items:center; align-items:center; margin:12px 0; }
    .ptz .dir{ width:44px; height:44px; border:2px solid #fff; border-radius:6px; display:flex; align-items:center; justify-content:center; cursor:pointer; }
  </style>
</head>
<body>

  <!-- 顶部栏由脚本 mountTopbar 注入（保持原样，不改） -->

  <!-- 下方主体：左侧为播放器（主画面+小窗），右侧为控制区 -->
  <div class="layout">
    <div class="videoPane">
      <div id="video_container">
        <div id="info_panel"></div>
        <div class="slot main" id="slot_main"></div>
        <div class="slot pip" id="slot_pip">
          <div id="pip_placeholder">副流小窗</div>
        </div>
        <div class="controls-overlay" id="controls_overlay">
          <div class="left-controls">
            <div class="volume-group">
              <button class="ctrl-btn" id="btn_mute" data-tip="音量/静音">
                <svg id="icon_volume" viewBox="0 0 24 24"><path d="M3 10v4h4l5 5V5L7 10H3zm13.5 2c0-1.77-1.02-3.29-2.5-4.03v8.06c1.48-.74 2.5-2.26 2.5-4.03z"/></svg>
                <svg id="icon_volume_off" viewBox="0 0 24 24" style="display:none"><path d="M16.5 12c0 1.77-1.02 3.29-2.5 4.03V7.97c1.48.74 2.5 2.26 2.5 4.03zM4.27 3 3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.26c-.67.52-1.42.93-2.25 1.17v2.07c1.38-.32 2.63-.99 3.68-1.92L19.73 21 21 19.73 4.27 3zM14 3.23v2.06c2.89.86 5 3.54 5 6.71 0 1.05-.25 2.05-.69 2.94l1.53 1.53A9.822 9.822 0 0 0 21 12c0-4.17-2.89-7.85-7-8.77z"/></svg>
              </button>
              <div class="volume-slider"><input id="volume_slider" type="range" min="0" max="1" step="0.01" value="1"></div>
            </div>
          </div>
          <div class="right-controls">
            <button class="ctrl-btn" id="btn_switch" data-tip="切换主/副画面" style="display:none;">
              <svg viewBox="0 0 24 24"><path d="M4 18h7v-2H6V6H4v12zm16-2V4H11v12h9zm0 2h-9v2h11V6h-2v12z"/></svg>
            </button>
            <button class="ctrl-btn" id="btn_info" data-tip="信息">
              <svg viewBox="0 0 24 24"><path d="M11 7h2v2h-2V7zm0 4h2v6h-2v-6zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/></svg>
            </button>
            <button class="ctrl-btn" id="btn_rotate" data-tip="旋转90°">
              <svg viewBox="0 0 24 24"><path d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26l1.46-1.46A5.97 5.97 0 0 1 6 12c0-3.31 2.69-6 6-6zm6.76 1.74-1.46 1.46c.47.89.7 1.9.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"/></svg>
            </button>
            <button class="ctrl-btn" id="btn_fit_fill" data-tip="自适应/填充">
              <svg id="icon_fit" viewBox="0 0 24 24"><path d="M4 4h7v2H6v5H4V4zm16 0v7h-2V6h-5V4h7zm0 16h-7v-2h5v-5h2v7zM4 20v-7h2v5h5v2H4z"/></svg>
              <svg id="icon_fill" viewBox="0 0 24 24" style="display:none"><path d="M7 7h10v10H7z"/><path d="M5 5v14h14V5H5zm12 12H7V7h10v10z"/></svg>
            </button>
            <button class="ctrl-btn" id="btn_fullscreen" data-tip="全屏">
              <svg id="icon_fullscreen" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zm-3-12v2h3v3h2V5h-5z"/></svg>
              <svg id="icon_fullscreen_exit" viewBox="0 0 24 24" style="display:none"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/></svg>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- 右侧控制区（保持你原有按钮与 ID，继续通过 WS 下发控制） -->
    <div class="side">
      <div>通道0</div>
      <div class="ptz">
        <div class="dir" id="btnPtzUp">▲</div>
        <div class="dir" id="btnPtzHome">●</div>
        <div class="dir" id="btnPtzRight">▶</div>
        <div class="dir" id="btnPtzLeft">◀</div>
        <div></div>
        <div class="dir" id="btnPtzDown">▼</div>
      </div>
      <div class="ctl">
        <div class="btn" id="btnReconnect">重连</div>
        <div class="btn" id="btnFlash">闪光灯</div>
        <div></div>
        <div class="btn" id="btnShot2">拍照</div>
        <div class="btn" id="btnRecord2">录像</div>
        <div class="btn" id="btnFullscreen">全屏</div>
      </div>
      <div class="ctl">
        <div class="btn" id="btnToggleVideo">打开/关闭视频</div>
        <div class="btn" id="btnSwitchChannel">切换</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { mountTopbar, detailBridge } from './common/detail-common.js';
    import { STREAMS } from '/config/streams.js';

    /* 顶部栏与桥接（保持原样，不改） */
    const qs = new URLSearchParams(location.search);
    const devId = qs.get('devId')||''; const devNo = qs.get('devNo')||'';
    const stream = qs.get('stream') || 'main'; // main/sub/screen

    const ui = mountTopbar(document.body); ui.lblDevNo.textContent = devNo || devId;
    const bridge = detailBridge(); bridge.ready({ page:'video', devId, devNo });

    /* --------- 以下为 player.html 的核心逻辑移植与融合 --------- */

    /* 调试日志 */
    (function(){
      const DBG_PREFIX='RTC7';
      const pad2=n=>('0'+n).slice(-2);
      function ts(){const d=new Date();return [pad2(d.getHours()),pad2(d.getMinutes()),pad2(d.getSeconds())].join(':')+'.'+(d.getMilliseconds()+'').padStart(3,'0');}
      const logger={
          enabled:true,
          d(tag,...a){ if(!this.enabled) return; try{console.log(`[${DBG_PREFIX} ${ts()}][${tag}]`,...a);}catch(_){} },
          i(tag,...a){ if(!this.enabled) return; try{console.info(`[${DBG_PREFIX} ${ts()}][${tag}]`,...a);}catch(_){} },
          w(tag,...a){ if(!this.enabled) return; try{console.warn(`[${DBG_PREFIX} ${ts()}][${tag}]`,...a);}catch(_){} },
          e(tag,...a){ if(!this.enabled) return; try{console.error(`[${DBG_PREFIX} ${ts()}][${tag}]`,...a);}catch(_){} },
      };
      window.__RTC_LOGGER__=logger;
      const scripts=[].map.call(document.scripts,s=>s.src||'(inline)');
      logger.i('ENV','UserAgent =', navigator.userAgent);
      logger.i('ENV','Scripts loaded =', scripts);
      logger.i('ENV','Adapter exists =', !!window.adapter);
      logger.i('ENV','SrsRtcPlayerAsync exists =', typeof window.SrsRtcPlayerAsync==='function');
    })();

    /* 渲染循环（全屏防闪烁） */
    function makeRenderLoop(draw){
      let run=false;
      function loop(){ if(!run) return; draw(); requestAnimationFrame(loop); }
      return { start(){ if(!run){run=true; requestAnimationFrame(loop);} }, stop(){ run=false; } };
    }

    /* SDP 辅助/PC 调试 */
    function parseH264ParamsFromSdp(sdp){
      const lines=(sdp||'').split(/\r?\n/), h264Pts=[], fmtpByPt={};
      for(const l of lines){
        const m=l.match(/^a=rtpmap:(\d+)\s+H264\/90000/i); if(m) h264Pts.push(m[1]);
        const f=l.match(/^a=fmtp:(\d+)\s+(.*)$/i); if(f) fmtpByPt[f[1]]=f[2];
      }
      return h264Pts.map(pt=>{
        const map={pt};
        (fmtpByPt[pt]||'').split(';').map(s=>s.trim()).forEach(kv=>{
          const [k,v]=kv.split('='); if(k) map[k.trim()]=(v||'').trim();
        });
        return map;
      });
    }
    function sdpHasVideo(sdp){ return /m=video\s+\d+\s+[\w/ ]+\s+/i.test(sdp||''); }
    function sdpDirectionForVideo(sdp){
      const m=(sdp||'').match(/m=video[\s\S]*?(?=m=|$)/i); if(!m) return ''; const block=m[0];
      const dir=block.match(/a=(sendrecv|sendonly|recvonly|inactive)/i); return dir?dir[1].toLowerCase():'';
    }
    function attachPcDebug(pc, tag){
      const log=window.__RTC_LOGGER__; if(!pc){ log.w(tag,'attachPcDebug: pc is null'); return; }
      try{
        pc.addEventListener('signalingstatechange',()=>log.i(tag,'signalingState =', pc.signalingState));
        pc.addEventListener('icegatheringstatechange',()=>log.i(tag,'iceGatheringState =', pc.iceGatheringState));
        pc.addEventListener('iceconnectionstatechange',()=>log.i(tag,'iceConnectionState =', pc.iceConnectionState));
        pc.addEventListener('connectionstatechange',()=>log.i(tag,'connectionState =', pc.connectionState));
        pc.addEventListener('icecandidateerror',e=>log.w(tag,'icecandidateerror', e.errorCode, e.errorText||e.url||'' ));
        pc.addEventListener('track',e=>{ log.i(tag,'ontrack kind=', e.track&&e.track.kind, 'streams=', e.streams&&e.streams.length); });
        setTimeout(()=>{
          const ld=pc.localDescription, rd=pc.remoteDescription;
          if(ld){
            log.i(tag,'Local SDP has m=video:', sdpHasVideo(ld.sdp), 'dir:', sdpDirectionForVideo(ld.sdp));
            const h264=parseH264ParamsFromSdp(ld.sdp); if(h264.length) log.i(tag,'Local H264 fmtp:', h264);
          }else log.w(tag,'LocalDescription not set yet');
          if(rd){
            log.i(tag,'Remote SDP has m=video:', sdpHasVideo(rd.sdp), 'dir:', sdpDirectionForVideo(rd.sdp));
            const h264=parseH264ParamsFromSdp(rd.sdp); if(h264.length) log.i(tag,'Remote H264 fmtp:', h264);
          }else log.w(tag,'RemoteDescription not set yet');
        },0);
        pc.getStats().then(rs=>{
          let pair=null, local=null, remote=null;
          rs.forEach(r=>{ if(r.type==='transport'&&r.selectedCandidatePairId){ pair=rs.get(r.selectedCandidatePairId); }});
          if(!pair){ rs.forEach(r=>{ if(r.type==='candidate-pair'&&(r.selected||r.nominated)) pair=r; }); }
          if(pair){
            local=rs.get&&rs.get(pair.localCandidateId); remote=rs.get&&rs.get(pair.remoteCandidateId);
            log.i(tag,'Selected pair:', {
              state: pair.state, nominated: pair.nominated, currentRTT: pair.currentRoundTripTime,
              local: local? {type:local.candidateType, ip:local.ip||local.address, protocol:local.protocol}:{},
              remote: remote? {type:remote.candidateType, ip:remote.ip||remote.address, protocol:remote.protocol}:{},
            });
          }else log.w(tag,'No selected candidate pair yet');
        }).catch(e=>log.w(tag,'getStats pair error', e));
      }catch(e){ window.__RTC_LOGGER__.w(tag,'attachPcDebug error', e); }
    }

    /* 画布播放器（与 player.html 一致） */
    function createRtcCanvasPlayer(isPip,onResolution){
      const TAG = isPip ? 'SUB' : 'MAIN';
      const log = window.__RTC_LOGGER__;
      const video=document.createElement('video');
      video.autoplay=true; video.muted=true; video.playsInline=true;
      video.style.position='absolute'; video.style.top='0'; video.style.left='0';
      video.style.width='1px'; video.style.height='1px'; video.style.opacity='0';
      document.body.appendChild(video);
      ['loadedmetadata','resize','playing','pause','waiting','stalled','suspend','abort','emptied','ended','error']
        .forEach(ev=>video.addEventListener(ev, e=>{
          if(ev==='error'){ const err=video.error; log.w(TAG,'video error', err&&err.code, err&&err.message); }
          else log.d(TAG,`video event: ${ev}`, {w:video.videoWidth,h:video.videoHeight,ready:video.readyState});
        }));
      const canvas=document.createElement('canvas');
      const ctx=canvas.getContext('2d');
      canvas.width=1280; canvas.height=720;

      let sdk=null, rotation=0, mode='fit';
      let stats={width:0,height:0,fps:0,vbit:0,abit:0, _hasV:false, _hasA:false};

      const loop=makeRenderLoop(()=>{
        const dispW=canvas.clientWidth||canvas.width;
        const dispH=canvas.clientHeight||canvas.height;
        const vw=video.videoWidth, vh=video.videoHeight;
        if(!vw||!vh) return;
        ctx.save();
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.translate(canvas.width/2,canvas.height/2);
        ctx.rotate(rotation*Math.PI/180);
        let videoW=vw, videoH=vh;
        if(rotation%180!==0) [videoW,videoH]=[videoH,videoW];
        let drawW=dispW, drawH=dispH;
        if(!isPip){
          if(mode==='fit'){
            const vr=videoW/videoH, cr=dispW/dispH;
            if(vr>cr){ drawW=dispW; drawH=dispW/vr; } else { drawH=dispH; drawW=dispH*vr; }
          }
        }
        const scaleX=canvas.width/dispW;
        const scaleY=canvas.height/dispH;
        if(rotation%180===0){
          ctx.drawImage(video,-drawW/2*scaleX,-drawH/2*scaleY,drawW*scaleX,drawH*scaleY);
        }else{
          ctx.drawImage(video,-drawH/2*scaleX,-drawW/2*scaleY,drawH*scaleX,drawW*scaleY);
        }
        ctx.restore();
      });

      function collectStats(pc){
        let last={}, firstVideoLogged=false;
        setInterval(()=>pc && pc.getStats().then(rs=>{
          rs.forEach(r=>{
            if(r.type==='inbound-rtp'&&r.kind==='video'){
              stats._hasV=true;
              const bytes=r.bytesReceived, frames=r.framesDecoded;
              const dBytes=last.v?bytes-last.v:0;
              const dFrames=last.f?frames-last.f:0;
              const w=r.frameWidth||0, h=r.frameHeight||0;
              stats.vbit=(dBytes*8/1000).toFixed(1);
              stats.fps=dFrames;
              if((w&&h)&&(w!==stats.width||h!==stats.height)){
                stats.width=w; stats.height=h;
                onResolution && onResolution(w,h,rotation);
              }else{
                stats.width=w; stats.height=h;
              }
              if(!firstVideoLogged && (w||h||frames>0)){
                firstVideoLogged=true;
                window.__RTC_LOGGER__.i(TAG,'inbound video detected',{w,h,fps:stats.fps, vkbps:stats.vbit});
              }
              last.v=bytes; last.f=frames;
            }
            if(r.type==='inbound-rtp'&&r.kind==='audio'){
              stats._hasA=true;
              const bytes=r.bytesReceived;
              const d=last.a?bytes-last.a:0;
              stats.abit=(d*8/1000).toFixed(1);
              last.a=bytes;
            }
          });
        }).catch(e=>window.__RTC_LOGGER__.w(TAG,'getStats error', e)),1000);
      }

      async function play(url){
        log.i(TAG,'play() start, url =', url);
        if(sdk){ try{sdk.close();}catch(_){} sdk=null; }
        sdk=new SrsRtcPlayerAsync();
        log.i(TAG,'SrsRtcPlayerAsync created:', !!sdk);
        video.srcObject=sdk.stream;

        // 守护：6s 内没有 inbound-rtp(video) 给出提示
        let watchdogTimer=null;
        function startWatchdog(){
          const t0=Date.now();
          watchdogTimer=setInterval(()=>{
            const elapse=(Date.now()-t0)/1000;
            if(elapse>=6){
              if(!stats._hasV){
                log.w(TAG,'No inbound-rtp(video) detected within 6s. Likely not negotiated/subscribed.');
              }
              clearInterval(watchdogTimer); watchdogTimer=null;
            }else{
              if(stats._hasA && !stats._hasV && elapse>=4){
                log.w(TAG,'Audio inbound but NO video inbound yet (4s). Suspect video not negotiated.');
              }
            }
          }, 1000);
        }

        try{
          startWatchdog();
          await sdk.play(url);
          log.i(TAG,'sdk.play() resolved');
          if(sdk.pc){ attachPcDebug(sdk.pc, TAG); }
          else{ log.w(TAG,'sdk.pc is not available after play()'); }
          loop.start();
          collectStats(sdk.pc);
        }catch(e){
          log.e(TAG,'sdk.play() failed', e);
          if(sdk){try{sdk.close();}catch(_){} sdk=null;}
        }
      }

      return {
        canvas, play,
        rotate:()=>{rotation=(rotation+90)%360; onResolution && onResolution(stats.width,stats.height,rotation); window.__RTC_LOGGER__.i(TAG,'rotate', rotation);},
        toggleMode:()=>{mode=(mode==='fit'?'fill':'fit'); window.__RTC_LOGGER__.i(TAG,'mode ->', mode);},
        getMode:()=>mode, getRotation:()=>rotation,
        getStats:()=>({...stats}),
        mute:(m)=>{video.muted=m; window.__RTC_LOGGER__.i(TAG,'mute', m);}, setVolume:(v)=>{video.volume=v; window.__RTC_LOGGER__.i(TAG,'volume', v);},
        getVideoEl:()=>video,
        attachToSlot:(slot)=>{slot.appendChild(canvas); window.__RTC_LOGGER__.i(TAG,'attachToSlot', slot&&slot.id);},
        isPip:()=>isPip, setPip:(v)=>{isPip=v; window.__RTC_LOGGER__.i(TAG,'setPip', v);}
      };
    }

    /* DOM 引用 */
    const container=document.getElementById('video_container');
    const slotMain=document.getElementById('slot_main');
    const slotPip=document.getElementById('slot_pip');
    const pipPlaceholder=document.getElementById('pip_placeholder');
    const infoPanel=document.getElementById('info_panel');

    const btnMute=document.getElementById('btn_mute');
    const iconVol=document.getElementById('icon_volume');
    const iconVolOff=document.getElementById('icon_volume_off');
    const volumeSlider=document.getElementById('volume_slider');
    const btnSwitch=document.getElementById('btn_switch');
    const btnInfo=document.getElementById('btn_info');
    const btnRotate=document.getElementById('btn_rotate');
    const btnFitFill=document.getElementById('btn_fit_fill');
    const iconFit=document.getElementById('icon_fit');
    const iconFill=document.getElementById('icon_fill');
    const btnFullscreen=document.getElementById('btn_fullscreen');
    const iconFS=document.getElementById('icon_fullscreen');
    const iconFSExit=document.getElementById('icon_fullscreen_exit');

    let pipUserMoved=false;
    let subVisible=false;

    /* 播放器实例（主/副） */
    const playerA=createRtcCanvasPlayer(false);
    const playerB=createRtcCanvasPlayer(true,onSmallResolution);
    let bigPlayer=playerA, smallPlayer=playerB;
    playerA.attachToSlot(slotMain);

    function onSmallResolution(w,h,rot){
      if(!subVisible) return;
      if(!smallPlayer.isPip()) return;
      if(pipUserMoved) return;
      adjustPipSize(w,h,rot);
      ensurePipInBounds(true);
    }
    function adjustPipSize(w,h,rot){
      if(!w||!h) return;
      if(rot%180!==0) [w,h]=[h,w];
      const maxW=300,maxH=200;
      let aspect=w/h;
      let tw=maxW, th=tw/aspect;
      if(th>maxH){th=maxH; tw=th*aspect;}
      tw=Math.round(tw); th=Math.round(th);
      slotPip.style.width=tw+'px'; slotPip.style.height=th+'px';
    }

    /* 控制条显隐 */
    function showControls(autoHide=true){
      container.classList.add('show-controls');
      if(showControls._timer) clearTimeout(showControls._timer);
      if(autoHide) showControls._timer=setTimeout(()=>container.classList.remove('show-controls'),2500);
    }
    container.addEventListener('mousemove',()=>showControls(true));
    container.addEventListener('mouseleave',()=>container.classList.remove('show-controls'));
    showControls(true);

    /* 音量/静音 */
    function refreshVolumeUI(){
      const v=bigPlayer.getVideoEl();
      if(v.muted||v.volume===0){iconVol.style.display='none';iconVolOff.style.display='';}
      else{iconVol.style.display='';iconVolOff.style.display='none';}
      volumeSlider.value=v.volume;
    }
    btnMute.addEventListener('click',()=>{const v=bigPlayer.getVideoEl();v.muted=!v.muted;refreshVolumeUI(); window.__RTC_LOGGER__.i('UI','toggle mute ->', v.muted);});
    volumeSlider.addEventListener('input',()=>{
      const val=parseFloat(volumeSlider.value);
      bigPlayer.setVolume(val);
      if(val>0) bigPlayer.mute(false);
      refreshVolumeUI();
    });

    /* 模式/旋转 */
    function refreshModeIcon(){
      if(bigPlayer.getMode()==='fit'){iconFit.style.display='';iconFill.style.display='none';btnFitFill.setAttribute('data-tip','自适应');}
      else{iconFit.style.display='none';iconFill.style.display='';btnFitFill.setAttribute('data-tip','填充');}
    }
    btnFitFill.addEventListener('click',()=>{bigPlayer.toggleMode();refreshModeIcon();});
    btnRotate.addEventListener('click',()=>bigPlayer.rotate());

    /* 全屏（本地容器） */
    btnFullscreen.addEventListener('click',()=>{
      window.__RTC_LOGGER__.i('UI','fullscreen toggle');
      if(!document.fullscreenElement){container.requestFullscreen&&container.requestFullscreen();}
      else{document.exitFullscreen&&document.exitFullscreen();}
    });
    document.addEventListener('fullscreenchange',()=>{
      const fs=!!document.fullscreenElement;
      iconFS.style.display=fs?'none':'';
      iconFSExit.style.display=fs?'':'none';
      window.__RTC_LOGGER__.i('UI','fullscreenchange', fs);
      if(!fs){
        ensurePipInBounds(true);
        requestAnimationFrame(()=>ensurePipInBounds(true));
        setTimeout(()=>ensurePipInBounds(true),120);
      }
    });
    new ResizeObserver(()=>ensurePipInBounds(true)).observe(container);

    /* 信息面板 */
    btnInfo.addEventListener('click',()=>{
      if(infoPanel.style.display==='none'||!infoPanel.style.display){infoPanel.style.display='block';updateInfoPanel();}
      else infoPanel.style.display='none';
    });
    function updateInfoPanel(){
      if(infoPanel.style.display==='none') return;
      const sBig=bigPlayer.getStats();
      let html=`<h4>大画面 <span class="badge-role">${bigPlayer===playerA?'主流':'副流'}</span></h4>`;
      html+=statsLines(sBig,bigPlayer);
      if(subVisible){
        const sSmall=smallPlayer.getStats();
        html+=`<h4 style="margin-top:6px;">小画面 <span class="badge-role secondary">${smallPlayer===playerA?'主流':'副流'}</span></h4>`;
        html+=statsLines(sSmall,smallPlayer);
      }
      infoPanel.innerHTML=html;
    }
    function statsLines(st,p){
      return `<div class="info-row"><span>分辨率</span><span>${st.width}x${st.height}</span></div>
              <div class="info-row"><span>帧率</span><span>${st.fps||'-'} fps</span></div>
              <div class="info-row"><span>视频码率</span><span>${st.vbit||'-'} kbps</span></div>
              <div class="info-row"><span>音频码率</span><span>${st.abit||'-'} kbps</span></div>
              <div class="info-row"><span>模式</span><span>${p.getMode()}</span></div>
              <div class="info-row"><span>旋转</span><span>${p.getRotation()}°</span></div>`;
    }
    setInterval(updateInfoPanel,1000);

    /* 切换主/副（本地 PiP 交换） */
    btnSwitch.addEventListener('click',()=>{
      if(!subVisible) return;
      window.__RTC_LOGGER__.i('UI','switch main/sub');
      bigPlayer.setPip(true);
      smallPlayer.setPip(false);

      const bigCanvas=bigPlayer.canvas;
      const smallCanvas=smallPlayer.canvas;
      const bigBefore=bigCanvas.getBoundingClientRect();
      const smallBefore=smallCanvas.getBoundingClientRect();

      slotMain.appendChild(smallCanvas);
      slotPip.appendChild(bigCanvas);

      const prev=bigPlayer; bigPlayer=smallPlayer; smallPlayer=prev;

      const bigAfter=smallCanvas.getBoundingClientRect();
      const smallAfter=bigCanvas.getBoundingClientRect();

      applyFlip(bigCanvas,smallBefore,smallAfter);
      applyFlip(smallCanvas,bigBefore,bigAfter);

      refreshVolumeUI();
      refreshModeIcon();
      updateInfoPanel();

      if(!pipUserMoved){
        const s=smallPlayer.getStats();
        if(s.width&&s.height){
          adjustPipSize(s.width,s.height,smallPlayer.getRotation());
          ensurePipInBounds(true);
        }
      }
    });
    function applyFlip(canvas,before,after){
      const dx=before.left-after.left;
      const dy=before.top-after.top;
      const sx=before.width/after.width;
      const sy=before.height/after.height;
      canvas.classList.add('swap-anim');
      canvas.style.transformOrigin='0 0';
      canvas.style.transform=`translate(${dx}px,${dy}px) scale(${sx},${sy})`;
      requestAnimationFrame(()=>{
        canvas.style.transform='translate(0,0) scale(1,1)';
        canvas.addEventListener('transitionend',function handler(){
          canvas.classList.remove('swap-anim');
          canvas.style.transform='';
          canvas.removeEventListener('transitionend',handler);
        });
      });
    }

    /* 小窗拖动 */
    (function enablePipDrag(){
      let dragging=false,startX,startY,origLeft,origTop;
      slotPip.addEventListener('mousedown',e=>{
        if(!subVisible) return;
        dragging=true; pipUserMoved=true;
        slotPip.classList.add('dragging');
        const vc=container.getBoundingClientRect();
        const rect=slotPip.getBoundingClientRect();
        origLeft=rect.left-vc.left; origTop=rect.top-vc.top;
        startX=e.clientX; startY=e.clientY;
        if(!slotPip.style.left && !slotPip.style.top){
          slotPip.style.left=origLeft+'px';
          slotPip.style.top=origTop+'px';
          slotPip.style.right='auto'; slotPip.style.bottom='auto';
        }
        e.preventDefault();
      });
      window.addEventListener('mousemove',e=>{
        if(!dragging) return;
        const vc=container.getBoundingClientRect();
        const dx=e.clientX-startX, dy=e.clientY-startY;
        const pipW=slotPip.offsetWidth, pipH=slotPip.offsetHeight;
        let newLeft=origLeft+dx, newTop=origTop+dy;
        if(newLeft<0)newLeft=0;
        if(newTop<0)newTop=0;
        if(newLeft+pipW>vc.width)newLeft=vc.width-pipW;
        if(newTop+pipH>vc.height)newTop=vc.height-pipH;
        slotPip.style.transform=`translate(${newLeft-origLeft}px,${newTop-origTop}px)`;
      });
      window.addEventListener('mouseup',()=>{
        if(!dragging) return;
        dragging=false;
        slotPip.classList.remove('dragging');
        const vc=container.getBoundingClientRect();
        const rect=slotPip.getBoundingClientRect();
        const finalLeft=rect.left-vc.left;
        const finalTop=rect.top-vc.top;
        slotPip.style.transform='';
        slotPip.style.left=finalLeft+'px';
        slotPip.style.top=finalTop+'px';
        slotPip.style.right='auto'; slotPip.style.bottom='auto';
        ensurePipInBounds(true);
      });
    })();

    /* 保证小窗在范围内（全屏退出/容器变化） */
    function ensurePipInBounds(forceReanchor){
      if(!subVisible) return;
      const vc=container.getBoundingClientRect();
      const rect=slotPip.getBoundingClientRect();
      const usingDefault = (!slotPip.style.left && !slotPip.style.top);
      if(usingDefault){
        if(forceReanchor && (rect.left>vc.right || rect.top>vc.bottom || rect.right<vc.left || rect.bottom<vc.top ||
           rect.right>vc.right || rect.bottom>vc.bottom)){
          slotPip.style.left=Math.max(vc.width - rect.width - 16,0)+'px';
          slotPip.style.top =Math.max(vc.height - rect.height - 96,0)+'px';
          slotPip.style.right='auto'; slotPip.style.bottom='auto';
        }
        return;
      }
      let left=parseFloat(slotPip.style.left)||0;
      let top =parseFloat(slotPip.style.top)||0;
      let changed=false;
      if(left+rect.width>vc.width){left=vc.width-rect.width; changed=true;}
      if(top+rect.height>vc.height){top=vc.height-rect.height; changed=true;}
      if(left<0){left=0; changed=true;}
      if(top<0){top=0; changed=true;}
      if(changed){
        slotPip.style.left=left+'px';
        slotPip.style.top=top+'px';
      }
    }

    /* 初始化 UI */
    refreshModeIcon();
    refreshVolumeUI();
    setTimeout(()=>container.classList.remove('show-controls'),2000);
    document.addEventListener('keydown',e=>{ if(e.code==='Space'){e.preventDefault();showControls(true);} });

    /* 使用配置 STREAMS 启动主/副流 */
    const urlMap = { main: STREAMS.main, sub: STREAMS.sub, screen: STREAMS.screen };
    const mainUrl = urlMap[stream] || STREAMS.main;
    if (mainUrl) {
      playerA.play(mainUrl);
    }
    if (STREAMS.sub) {
      playerB.play(STREAMS.sub);
      // 展示小窗
      smallPlayer=playerB;
      playerB.attachToSlot(slotPip);
      slotPip.style.display='block';
      pipPlaceholder.style.display='none';
      subVisible=true;
      btnSwitch.style.display='inline-flex';
    }

    /* ------------------- WS 通道与按钮绑定（保持原有行为） ------------------- */
    const ch = await bridge.wsOpen({ kind:'video', devId });
    const to = { type: 1, id: devId };

    // 顶栏按钮
    ui.btnShot.onclick   = ()=> bridge.wsSend(ch, { cmd:'videoShot', to });
    ui.btnRecord.onclick = ()=> bridge.wsSend(ch, { cmd:'videoRecordToggle', to });
    ui.btnTalk.onclick   = ()=> bridge.wsSend(ch, { cmd:'talkToggle', to });
    ui.btnBack.onclick   = ()=> parent.postMessage({ __detail:true, t:'back' }, '*');

    // 右侧侧栏按钮 -> WS
    const bind = (id, cmd, data={})=> document.getElementById(id).onclick = ()=> bridge.wsSend(ch, { cmd, to, data });
    bind('btnPtzUp','ptz', { dir:'up' });
    bind('btnPtzDown','ptz', { dir:'down' });
    bind('btnPtzLeft','ptz', { dir:'left' });
    bind('btnPtzRight','ptz', { dir:'right' });
    bind('btnPtzHome','ptz', { dir:'home' });
    bind('btnReconnect','videoReconnect');
    bind('btnFlash','flashToggle');
    bind('btnShot2','videoShot');
    bind('btnRecord2','videoRecordToggle');
    bind('btnFullscreen','videoFullscreen');
    bind('btnToggleVideo','videoToggle');
    bind('btnSwitchChannel','videoSwitch');

    bridge.onWsMessage((m)=>{ /* 处理视频事件，如进度、错误等 */ });
  </script>
</body>
</html>